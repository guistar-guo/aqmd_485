2024年天津科技大学-ROBOTAC大赛-速胜组自动机器人-stm32下位机
队伍名：SuperEgo
指   导：史松云
作   者：郭耀辉

简介：本keil工程用于速胜组的自动机器人下位机，使用淘宝店铺购买的C50C单片机主控板。

淘宝链接：https://m.tb.cn/h.g4yjXia?tk=wlIbWCkdZhG

////////////////////////////////

更新日志：
*******************fast_win_0_1**********************
2024/6/9
1.建立初版工程，使用基于stm32cubemx生成的CMSIS_V2的实时操作系统（freertos）。
2.添加C50C板载的RGB-led程序。
3.添加板载OLED驱动程序。
4.实现串口3的printf重定向。
5.添加了之前写好的CODBOT ROS机器人通讯协议（代码位于sbus.c文件中）。
6.编写串口5的sbus解析代码，但是由于今天(2024/6/9)没有板载接口的类型，故无法验证代码的正确性。

*******************fast_win_0_2**********************
2024/6/10
1.优化了串口部分的代码，每个串口的代码风格更统一，更易于阅读
2.考虑到串口部分代码的实际作用不仅仅限于sbus协议，更名原0_1版本的文件sbus.c，sbus.h为usartx.c，usartx.h
3.通过串口5实现sbus协议解析

*******************fast_win_0_3**********************
2024/6/11
1.新增蜂鸣器模块，它的三个宏操作放在LED.h中
2.新增陀螺仪模块，在C50C开发板上面，板载自带有一个陀螺仪，它连接着IIC1接口(占用PB8,PB9,PD3引脚)，本次更新添加了它的原始数据读取驱动代码，读取陀螺仪六轴原始数据的示例代码位于mpua6050.h文件的最后的注释
3.在实现陀螺仪的过程中，使用到了位带操作，所谓位带操作，就是将stm32f4的引脚映射到stm32内部RAM的某一位，用户只需通过简单的赋值操作或者直接读取这个位的状态即可写IO或者读IO，位带操作需要映射到RAM的某一位，因此这个映射操作需要程序员来计算相应的位地址。不过正点原子开源了位带映射的代码，通过正点原子提供的代码，可以很方便的映射某一位实现位带操作，具体映射代码见system.h，具体的使用例子见I2C.c

*******************fast_win_0_4**********************
2024/6/11
1.考虑到现阶段的代码开发不属于应用方面的代码开发，大多数开发都是模块驱动的代码更新，因此更名原来的APP文件夹为BSP，并且新增一个空的APP文件夹供将来做应用的代码存放

2024/6/12
2.新增一个系统软件定时器，用于产生系统节拍systick，和维护系统指示灯闪烁(这个工作在旧版本由任务1负责)，systick是一个32位的变量，每隔一个系统周期(1ms)都会在系统软件定时器的回调函数中加1

*******************fast_win1.0**********************
2024/6/13
1.新增编码器ABCD驱动代码
2.新增编码器的驱动代码，与张金波配合完成电机PWM驱动正反转的测试
3.附录里面新增厂家文档“C50C集成板资源分配(2023.10.17).pdf”，便于后续开发参考硬件资源

*******************fast_win1.1**********************
2024/6/13
1.发现了一个逆天bug：如果在rtos中的某个任务的主循环中什么也不干，但是也不延时，即如下操作：
while(1){} 或者for (;;){}
那么会导致很严重的问题：无法进入中断函数，例如：1.0版本删除了for循环中的所有内容，结果系统心跳led直接停止闪烁了。(系统心跳led底层依赖于定时中断)
这也是为什么cubemx在生成任务代码的时候，即使任务主循环什么也不干，但是仍然要osDelay(1)的原因。后续开发需要时刻注意这个问题！

2.升级了系统led心跳功能，板载的led-RGB灯由三个gpio控制，分别负责红绿蓝颜色，而旧版的心跳led一直是红色的。为了合理运用这三个gpio，同时考虑到：后续的开发可能需要系统在不同的时间段处于不同的状态，如：前30s进行系统初始化，然后再进行电机闭环控制等。因此需要通过led灯闪烁的颜色来指示系统当前处在哪一个阶段。

所以本次更新升级了旧版的心跳led，现在用户可以在任意地方调用led.c里面的system_led_switch_color函数来改变心跳led的颜色(可变为红绿蓝三种)


*******************fast_win1.2-电机，编码器实测**********************
2024/6/14
1.修复电机刚上电瞬间满转一小段时间的bug
2.测试在pwm驱动电机D的同时，显示编码器D的数值，成功验证了进行pid闭环算法的先决条件-pid的输入(编码器)，pid的输出(电机pwm)都可以通过主控读取和控制。

*******************fast_win2.0-大更新！**********************
2024/6/14
1.大改之前的motor.c，对于电机的操作函数，使用一个统一的结构体Motor来管理四个电机，定义了四个Motor结构体：motorA, motorB, motorC, motorD。并使用extern关键字修饰供用户在其他文件中使用。将之前写好的pwm设置函数，编码器相关函数，关联为电机结构体的成员。并使用static隐藏这些底层函数。用户在其他文件中只需通过访问motorA, motorB, motorC, motorD就可以操作相应的电机

例如：motorB.set_pwm(-2000);	//设置电机B的pwm值为2000，方向反转
motorB.Get_encoder();		//返回编码器B的当前计次值值

其他成员的细节参考motor.h的Motor结构体

以上更新，总结就是：使用面向对象的思想将四个电机的所有重要函数和变量封装在同一的结构体接口，更方便用户直接控制电机。

2.完成四个电机的增量式pi闭环控制。用户只需运行motor_task任务，即可完成四个电机的闭环控制，四个电机的目标速度默认为0，如果要修改pi控制的目标速度，只需要修改电机结构体的target_speed成员即可。

例如：
motorD.target_speed = 20;	//修改电机D的目标速度为20

需要注意！必须保证motor_task任务处在运行状态，才会进行pi速度换控制！可以把他放在rtos的任意一个任务的初始化位置(for(;;)之前)即可

具体pid算法细节参考motor.c


*******************fast_win2.1**********************
2024/6/14

1.新增电机极性设置宏，位于motor.h的最开头：
#define MOTORA_POLARITY 1
#define MOTORB_POLARITY 1
#define MOTORC_POLARITY 1
#define MOTORD_POLARITY 1
给1或-1来设置两个相反的极性，当电机极性相反的话，不必再更改硬件AB相接线了，只需更改上述四个宏即可改变对应电机的极性

2.应队长闫旭的要求，为一些代码添加了注释，bsp的所有.c文件的最开始都添加了注释来简单介绍这个.c文件的一些特性用途

*******************fast_win2.2**********************
2024/6/14

1.新增编码器极性设置宏，位于encoder.h的最开头：
#define ENCODERA_POLARITY 1
#define ENCODERB_POLARITY 1
#define ENCODERC_POLARITY 1
#define ENCODERD_POLARITY 1

2024/6/16
2.内测平滑函数，但是此版本暂时止步于此，是因为作者此时并没有信心能把平滑的相关功能写完美，所以备份一个版本，方便将来滚动更新回来

*******************fast_win2.3**********************
2024/6/16
1.新增平滑输出函数，用户调用一下接口来平滑控制电机：
motorD.speed = 20;	//设置电机D的速度为20，且为平滑控制速度达到20(即不会突变的控制速度慢慢达到20)

提醒：此版本之后，禁止用户再调用电机结构体的target_speed成员，因为内部算法是以speed为依据进行控制target_speed的

至此，关于电机的底层驱动全部完成，接下来的开发将偏向于通过电机结构体的speed成员来控制电机的行为

2.事实证明，2.2版本的平滑代码确实写的很烂，2.3版本仔细斟酌了这个问题，然后改进完善了平滑的代码，不过2.2版本的设置编码器极性这一功能是非常具有实际意义的


*******************fast_win2.4**********************
2024/6/16
1.新增串口3无阻塞发送函数：void dma_printf (char *fmt, ...)(非常重要)，并改进了sbus解析打印通道的函数为无阻塞发送的方式
参考作者b站视频：https://www.bilibili.com/video/BV1AvVLeGEwS/?spm_id_from=333.999.0.0

2.新增富斯遥控的通道1，2来控制电机CD的程序，这是本项目的第一个应用程序，代码部分放在fsi6_control_motor.c中，位于APP文件夹下

*******************fast_win2.5**********************
2024/6/21
1.新增5个舵机的驱动代码servos.c，代码位于bsp文件夹

*******************fast_win2.6**********************
2024/7/13
1.和队友探讨，最终确定，本车采用二轮差速+全向轮的驱动方案，因此，本次更新将针对这个方案

2.”二轮差速 + 全向轮“方案，两个驱动选择电机C，D ，C右轮子，D左轮子。新增motor_pi_control函数，它有两个输入参数，分别控制电机D，电机C的目标速度

3.新增motor_getCD_speed来获取电机的当前速度，如果发现显示数据的极性不对，则只需更改本函数体的相关语句即可

*******************fast_win2.7**********************
2024/7/13
1.新增PWM开环控制电机系统，代码位于motor.c的最后部分，目前该系统只有一个函数set_motorDC_pwm，用来设置电机D，C的PWM

pwm开环控制相比速度闭环具有一个很大的优势-反应很快！通过直接改变电机的占空比来一步到位直接控制电机的电压，但是需要付出的代价就是由于没有速度反馈，速度无法闭环控制某一个定值

*******************fast_win2.8_红外传感器驱动**********************
2024/7/14

新增五路红外传感器模块的驱动infrared.c，infrared.h，位于bsp文件夹下，它有两个函数，介绍如下：

1.函数infrared_get_data：返回五路红外的数据(二进制形式)，例如，最左侧的红外探测到黑线，则返回10000b

2.1.函数infrared_oled_show：将五路红外的数据显示在oled屏幕上

3.工程大小优化，配置cubemx为仅复制必要文件，旧版工程大小在126M左右(不包括编译后产生的中间文件)，优化后，工程大小在92M左右

*******************fast_win2.9**********************
2024/7/15
1.为保证后续用于机构上的电机（用A或者B）的编码器相关代码正常使用，注释掉闭环相关的AB电机的代码，只保留电机CD的速度闭环代码

2.新增推杆电机的驱动代码pushrod.c，目前的功能有：通过pwm控制推杆电机的电压，通过编码器A读取推杆电机的编码器计数值

*******************fast_win_3.0**********************
1.推杆电机位置闭环实现
2.bsp基本全部完成，剩下的工作是做应用程序app


*******************fast_win_3.1**********************
2024/7/16
1.添加两个应用任务，并且编写了任务的挂起与恢复例程，临界区的使用示范

*******************fast_win_3.2**********************
2024/7/16
1.新增rtos_printf阻塞打印函数，其原理是通过freertos的临界区来发送字符串，保证了在多个任务中使用打印函数不会发生打印覆盖的情况，利于应用程序的调试

*******************fast_win_3.3**********************
2024/7/16
1.优化oled屏幕显示的美观度，并且将oled显示的任务统一由StartDefaultTask负责
目前oled显示的内容如下：
第一行：SuperEgo队伍名称
第二行：五路红外传感器的当前状态
第三行：推杆电机编码器的值
第四行：左电机的编码器的值 和 右电机的编码器的值

*******************fast_win_3.4**********************
2024/7/17
1.今天整车刚装出来，重新调整电机，编码器的极性，调节过程中烧坏了一个编码器D，因此3.3版本将电机D的编码器调整为编码器B

2.调整好电机极性之后，编写遥控控制四个电机的pwm使小车运转

*******************fast_win_3.5**********************
2024/7/17
1.新增小车循迹应用程序，后续的应用程序代码架构，初步确定以循迹的任务为核心，在它的基础上编写其他的逻辑（例如：路口判断，转弯90度，45度，180度，控制机械臂抓取动作

*******************fast_win_3.6**********************
2024/7/18
1.编写基本的运动动作，供后续的调度内核使用

*******************fast_win_4.0**********************
2024/7/18
1.新增应用内核，以循迹为主线任务，后续需要将每个路口的动作添加在state1，state2...对应的代码即可，应用内核使本工程的最终框架！！

*******************fast_win_4.1**********************
1.分时控制，控制过程复杂，非人类的代码模式！放弃此版本

*******************fast_win_4.2**********************
2024/7/18
1.过程控制，基本实现所有过程







